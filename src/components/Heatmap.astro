---

---

<div class="heatmap p-4">
  <h3 class="text-xl font-semibold mb-4">
    R√©partition des types de patrimoine par EPCI dans le Doubs
  </h3>

  <div
    id="heatmap-container"
    class="rounded-lg p-4 min-h-96 flex items-center justify-center"
  >
    <span class="loading loading-spinner loading-lg"></span>
    <span class="ml-2">Chargement de la heatmap...</span>
  </div>
</div>

<script>
  import * as Plot from "@observablehq/plot";
  import * as d3 from "d3";

  let basilicData, epciGeoJSON;
  let donneesHeatmapAvecNoms;

  // Fonction pour cat√©goriser les types (comme dans Observable)
  function categoriserType(type_lieu) {
    if (!type_lieu) return "Autre";

    const type = type_lieu.toLowerCase();

    if (type.includes("mus√©e")) return "Mus√©es";
    if (type.includes("monument")) return "Monuments";
    if (type.includes("arch√©ologique") || type.includes("site arch√©o"))
      return "Sites arch√©ologiques";
    if (type.includes("archives")) return "Archives";
    if (type.includes("espace prot√©g√©")) return "Espaces prot√©g√©s";

    return "Autre";
  }

  async function loadData() {
    try {
      // Chargement des donn√©es
      [basilicData, epciGeoJSON] = await Promise.all([
        d3.json("/src/assets/basilic_final.json"),
        d3.json("/src/assets/intercomunalites.json"),
      ]);

      console.log(
        `‚úÖ Donn√©es charg√©es: ${basilicData.length} lieux, ${epciGeoJSON.features.length} EPCI`
      );

      prepareHeatmapData();
    } catch (error) {
      console.error("‚ùå Erreur lors du chargement:", error);
      showError(`Erreur de chargement: ${error.message}`);
    }
  }

  function prepareHeatmapData() {
    // Filtrer les lieux du Doubs et ajouter la cat√©gorisation
    const basilicAvecCategorie = basilicData
      .filter((d) => d.code_departement === "25")
      .map((d) => ({
        ...d,
        categorie_patrimoine: categoriserType(d.type_lieu),
      }));

    console.log(
      `üìç Lieux du Doubs avec cat√©gorie: ${basilicAvecCategorie.length}`
    );

    // Cr√©er un annuaire des noms EPCI
    const epciNoms = Object.fromEntries(
      epciGeoJSON.features.map((f) => [
        String(f.properties.siren_epci),
        f.properties.nom_epci ||
          f.properties.nom_court ||
          `EPCI ${f.properties.siren_epci}`,
      ])
    );

    // Cr√©er les donn√©es heatmap : compter par EPCI et cat√©gorie
    const donneesHeatmapRaw = d3.rollup(
      basilicAvecCategorie.filter((d) => d.code_insee_epci),
      (v) => v.length,
      (d) => d.code_insee_epci,
      (d) => d.categorie_patrimoine
    );

    // Convertir en format plat avec noms EPCI
    donneesHeatmapAvecNoms = Array.from(
      donneesHeatmapRaw,
      ([epci, categories]) => {
        return Array.from(categories, ([categorie, count]) => ({
          code_insee_epci: epci,
          nom_epci: epciNoms[epci] || `EPCI ${epci}`,
          categorie: categorie,
          nombre: count,
        }));
      }
    ).flat();

    console.log(
      `üìä Donn√©es heatmap: ${donneesHeatmapAvecNoms.length} cellules`
    );
    console.log(`üè∑Ô∏è Cat√©gories uniques:`, [
      ...new Set(donneesHeatmapAvecNoms.map((d) => d.categorie)),
    ]);
    console.log(
      `üèõÔ∏è EPCI uniques:`,
      [...new Set(donneesHeatmapAvecNoms.map((d) => d.nom_epci))].length
    );

    createHeatmap();
  }

  function createHeatmap() {
    try {
      if (!donneesHeatmapAvecNoms || donneesHeatmapAvecNoms.length === 0) {
        showError("Aucune donn√©e disponible pour la heatmap");
        return;
      }

      const plot = Plot.plot({
        title:
          "R√©partition des types de patrimoine par EPCI (√©tablissement public de coop√©ration intercommunale).",
        width: 1100,
        height: 600,
        marginBottom: 100,
        marginLeft: 330,

        x: {
          label: "Type de patrimoine",
          tickRotate: -45,
        },

        y: {
          label: null,
          domain: [
            ...new Set(donneesHeatmapAvecNoms.map((d) => d.nom_epci)),
          ].sort(),
        },

        color: {
          type: "sequential",
          scheme: "BuGn",
          legend: true,
          label: "Nombre de lieux",
        },

        marks: [
          // Cellules de la heatmap
          Plot.cell(donneesHeatmapAvecNoms, {
            x: "categorie",
            y: "nom_epci",
            fill: "nombre",
            tip: true,
            title: (d) => `${d.nom_epci}\n${d.categorie}: ${d.nombre} lieu(x)`,
          }),

          // Texte sur les cellules
          Plot.text(donneesHeatmapAvecNoms, {
            x: "categorie",
            y: "nom_epci",
            text: (d) => d.nombre,
            fill: (d, i, data) => {
              const maxNombre = d3.max(data, (item) => item.nombre) || 1;
              return d.nombre > maxNombre * 0.5 ? "white" : "black";
            },
            fontSize: 11,
            fontWeight: "bold",
          }),
        ],
      });

      const container = document.getElementById("heatmap-container");
      container.innerHTML = "";
      container.appendChild(plot);

      console.log(
        `‚úÖ Heatmap cr√©√©e avec ${donneesHeatmapAvecNoms.length} cellules`
      );
    } catch (error) {
      console.error("‚ùå Erreur heatmap:", error);
      showError(`Erreur d'affichage: ${error.message}`);
    }
  }

  function showError(message) {
    const container = document.getElementById("heatmap-container");
    container.innerHTML = `<div class="alert alert-error"><span>${message}</span></div>`;
  }

  async function init() {
    await loadData();
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
</script>
