---

---

<div class="ratio-doubs p-4">
  <h3 class="text-xl font-semibold mb-4">
    Ratio de lieux patrimoniaux par EPCI dans le Doubs
  </h3>

  <!-- Filtre -->
  <div class="form-control w-full max-w-xs mb-4">
    <label class="label">
      <span class="label-text">Filtrer les lieux par type de patrimoine</span>
    </label>
    <select
      id="categorie-select"
      class="select select-bordered w-full max-w-xs"
    >
      <option value="Tous les lieux">Tous les lieux</option>
    </select>
  </div>

  <div
    id="carte-ratio-container"
    class="bg-base-200 rounded-lg p-4 min-h-96 flex items-center justify-center"
  >
    <span class="loading loading-spinner loading-lg"></span>
    <span class="ml-2">Chargement de la carte...</span>
  </div>
</div>

<script>
  import * as Plot from "@observablehq/plot";
  import * as d3 from "d3";

  let basilicData, epciGeoJSON, lieuxDoubsData;
  let lieuxDoubsPourCarte, categoriesUniques;

  // Fonction pour cat√©goriser les types (comme dans Observable)
  function categoriserType(type_lieu) {
    if (!type_lieu) return "Autre";

    const type = type_lieu.toLowerCase();

    if (type.includes("mus√©e")) return "Mus√©es";
    if (type.includes("monument")) return "Monuments";
    if (type.includes("arch√©ologique") || type.includes("site arch√©o"))
      return "Sites arch√©ologiques";
    if (type.includes("archives")) return "Archives";
    if (type.includes("espace prot√©g√©")) return "Espaces prot√©g√©s";

    return "Autre";
  }

  async function loadData() {
    try {
      // Chargement des donn√©es essentielles
      [basilicData, epciGeoJSON] = await Promise.all([
        d3.json("/src/assets/basilic_final.json"),
        d3.json("/src/assets/intercomunalites.json"),
      ]);

      // V√©rification des donn√©es
      if (!basilicData || !Array.isArray(basilicData)) {
        throw new Error("Donn√©es Basilic non disponibles");
      }

      if (!epciGeoJSON || !epciGeoJSON.features) {
        throw new Error("Donn√©es EPCI non disponibles");
      }

      console.log(
        `‚úÖ Donn√©es charg√©es: ${basilicData.length} lieux, ${epciGeoJSON.features.length} EPCI`
      );

      // Filtrer les lieux du Doubs (code d√©partement 25)
      lieuxDoubsData = basilicData.filter(
        (item) => item.code_departement === "25"
      );

      console.log(`üìç Lieux dans le Doubs: ${lieuxDoubsData.length}`);

      prepareCarteData();
    } catch (error) {
      console.error("‚ùå Erreur lors du chargement:", error);
      showError(`Erreur de chargement: ${error.message}`);
    }
  }

  function prepareCarteData() {
    // Pr√©parer les points pour la carte avec cat√©gorisation
    lieuxDoubsPourCarte = lieuxDoubsData
      .filter(
        (lieu) =>
          lieu.latitude &&
          lieu.longitude &&
          !isNaN(parseFloat(lieu.latitude)) &&
          !isNaN(parseFloat(lieu.longitude))
      )
      .map((lieu) => ({
        nom_lieu: lieu.nom_lieu || "Lieu sans nom",
        latitude: parseFloat(lieu.latitude),
        longitude: parseFloat(lieu.longitude),
        type_lieu: lieu.type_lieu || "Non class√©",
        categorie_patrimoine: categoriserType(lieu.type_lieu),
        commune: lieu.commune || "Commune inconnue",
        code_insee_epci: lieu.code_insee_epci,
      }));

    // Extraire les cat√©gories uniques bas√©es sur categorie_patrimoine
    const categoriesBrutes = lieuxDoubsPourCarte.map(
      (d) => d.categorie_patrimoine
    );
    const categoriesNettoyees = [...new Set(categoriesBrutes)]
      .filter((cat) => cat && cat !== "Autre" && cat.trim() !== "")
      .sort();

    categoriesUniques = ["Tous les lieux", ...categoriesNettoyees];

    // Si pas de cat√©gories trouv√©es, ajouter "Autre"
    if (categoriesNettoyees.length === 0) {
      categoriesUniques.push("Autre");
    }

    console.log(`üè∑Ô∏è Cat√©gories trouv√©es:`, categoriesNettoyees);
    console.log(
      `üìä R√©partition:`,
      categoriesNettoyees.map((cat) => ({
        categorie: cat,
        nombre: categoriesBrutes.filter((c) => c === cat).length,
      }))
    );

    updateCategorieSelect();
  }

  function updateCategorieSelect() {
    const select = document.getElementById("categorie-select");
    if (select && categoriesUniques) {
      select.innerHTML = "";
      categoriesUniques.forEach((cat) => {
        const option = document.createElement("option");
        option.value = cat;
        option.textContent = cat;
        select.appendChild(option);
      });
    }
  }

  function createCarte(selectedCategorie = "Tous les lieux") {
    try {
      // Filtrage des points selon la cat√©gorie s√©lectionn√©e
      const lieuxFiltres = lieuxDoubsPourCarte.filter((d) => {
        if (selectedCategorie === "Tous les lieux") return true;
        return d.categorie_patrimoine === selectedCategorie;
      });

      console.log(
        `üîç Filtrage: "${selectedCategorie}" -> ${lieuxFiltres.length} lieux`
      );

      if (lieuxFiltres.length === 0) {
        showError(`Aucun lieu trouv√© pour la cat√©gorie "${selectedCategorie}"`);
        return;
      }

      // Calculer les statistiques EPCI bas√©es sur les lieux filtr√©s
      const epciLieuxMap = new Map();

      lieuxFiltres.forEach((lieu) => {
        if (lieu.code_insee_epci) {
          const count = epciLieuxMap.get(lieu.code_insee_epci) || 0;
          epciLieuxMap.set(lieu.code_insee_epci, count + 1);
        }
      });

      // Enrichir le GeoJSON avec les ratios
      const epciAvecRatioFiltre = {
        ...epciGeoJSON,
        features: epciGeoJSON.features.map((feature) => {
          const sirenEpci = feature.properties.siren_epci;
          const nbLieuxFiltres = epciLieuxMap.get(String(sirenEpci)) || 0;

          // Population estim√©e bas√©e sur la superficie
          const superficie = feature.properties.st_area_sh || 10000000;
          const populationEstimee = Math.max(
            1000,
            Math.round(superficie / 5000)
          );
          const ratio =
            populationEstimee > 0
              ? (nbLieuxFiltres / populationEstimee) * 10000
              : 0;

          return {
            ...feature,
            properties: {
              ...feature.properties,
              nb_lieux: nbLieuxFiltres,
              ratio_10k_habitants: ratio,
              population_estimee: populationEstimee,
              nom_epci:
                feature.properties.nom_epci ||
                feature.properties.nom_court ||
                "EPCI",
            },
          };
        }),
      };

      // Calcul du domaine du ratio pour la l√©gende
      const ratioValues = epciAvecRatioFiltre.features
        .map((f) => f.properties.ratio_10k_habitants)
        .filter((r) => r > 0);

      const minRatio = d3.min(ratioValues) || 0;
      const maxRatio = d3.max(ratioValues) || 1;

      const plot = Plot.plot({
        title:
          "Ratio de lieux patrimoniaux / 10K habitants par EPCI dans le Doubs",
        subtitle: `Cat√©gorie affich√©e : ${selectedCategorie} (${lieuxFiltres.length} lieux)`,
        width: 900,
        height: 600,
        projection: { type: "mercator", domain: epciGeoJSON },

        color: {
          type: "sequential",
          scheme: "YlGnBu",
          domain: [minRatio, maxRatio],
          legend: true,
          label: "Ratio / 10K hab.",
          tickFormat: ".1f",
        },

        marks: [
          // 1. Polygones EPCI (couleur = ratio)
          Plot.geo(epciAvecRatioFiltre, {
            fill: (d) => d.properties.ratio_10k_habitants,
            stroke: "#fff",
            strokeWidth: 0.5,
            title: (d) =>
              `${d.properties.nom_epci}\n` +
              `Ratio : ${d.properties.ratio_10k_habitants.toFixed(2)} / 10K hab.\n` +
              `Lieux (${selectedCategorie}) : ${d.properties.nb_lieux}\n` +
              `Pop. estim√©e : ${d.properties.population_estimee.toLocaleString()}`,
            tip: true,
          }),

          // 2. Points des lieux patrimoniaux
          Plot.dot(lieuxFiltres, {
            x: "longitude",
            y: "latitude",
            r: 3,
            opacity: 0.8,
            fill: "red",
            stroke: "white",
            strokeWidth: 0.5,
            tip: true,
            title: (d) =>
              `${d.nom_lieu}\nType: ${d.categorie_patrimoine}\nCommune: ${d.commune}`,
          }),

          // 3. Fronti√®res EPCI
          Plot.geo(epciGeoJSON, {
            stroke: "black",
            strokeOpacity: 0.3,
            fill: "none",
          }),
        ],
      });

      const container = document.getElementById("carte-ratio-container");
      container.innerHTML = "";
      container.appendChild(plot);
      container.className = "carte-ratio-content";

      console.log(`‚úÖ Carte cr√©√©e avec ${lieuxFiltres.length} points`);
    } catch (error) {
      console.error("‚ùå Erreur carte:", error);
      showError(`Erreur d'affichage: ${error.message}`);
    }
  }

  function showError(message) {
    const container = document.getElementById("carte-ratio-container");
    container.innerHTML = `<div class="alert alert-error"><span>${message}</span></div>`;
  }

  async function init() {
    await loadData();

    if (lieuxDoubsPourCarte && lieuxDoubsPourCarte.length > 0) {
      createCarte("Tous les lieux");

      // Event listener pour le filtre
      document
        .getElementById("categorie-select")
        .addEventListener("change", (e) => {
          console.log(`üéØ Changement de filtre: ${e.target.value}`);
          createCarte(e.target.value);
        });
    } else {
      showError("Aucune donn√©e disponible pour le Doubs");
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
</script>
